<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Meelgroup on Meelgroup</title>
    <link>/</link>
    <description>Recent content in Meelgroup on Meelgroup</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Scalable Approximate Model Counter </title>
      <link>/publication/cp2013/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/cp2013/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Propositional model counting (#SAT), i.e., counting the number of satisfying assignments of a propositional formula, is a problem of significant theoretical and practical interest. Due to the inherent complexity of the problem, approximate model counting, which counts the number of satisfying assignments to within given tolerance and confi- dence level, was proposed as a practical alternative to exact model counting. Yet, approximate model counting has been studied essentially only theoretically. The only reported implementation of approximate model counting, due to Karp and Luby, worked only for DNF formulas. A few existing tools for CNF formulas are bounding model counters; they can handle realistic problem sizes, but fall short of providing counts within given tolerance and confidence, and, thus, are not approximate model counters. We present here a novel algorithm, as well as a reference implementation, that is the first scalable approximate model counter for CNF formulas. The algorithm works by issuing a polynomial number of calls to a SAT solver. Our tool, ApproxMC, scales to formulas with tens of thousands of variables. Careful experimental comparisons show that ApproxMC reports, with high confidence, bounds that are close to the exact count, and also succeeds in reporting bounds with small tolerance and high confidence in cases that are too large for computing exact model counts.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Scalable and Nearly Uniform Generator of SAT Witnesses</title>
      <link>/publication/cav13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/cav13/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Functional verification constitutes one of the most challenging tasks in the development of modern hardware systems, and simulation-based verification techniques dominate the functional verification landscape. A dominant paradigm in simulation-based verification is directed random testing, where a model of the system is simulated with a set of random test stimuli that are uniformly or near-uniformly distributed over the space of all stimuli satisfying a given set of constraints. Uniform or near-uniform generation of solutions for large constraint sets is therefore a problem of theoretical and practical interest. For Boolean constraints, prior work offered heuristic approaches with no guarantee of performance, and theoretical approaches with proven guarantees, but poor performance in practice. We offer here a new approach with theoretical performance guarantees and demonstrate its practical utility on large constraint sets.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithmic Improvements in Approximate Counting for Probabilistic Inference: From Linear to Logarithmic SAT Calls  </title>
      <link>/publication/ijcai16_counting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/ijcai16_counting/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Probabilistic inference via model counting has emerged as a scalable technique with strong formal guarantees, thanks to recent advances in hashing-based approximate counting. State-of-the-art hashing-based counting algorithms use an {\NP} oracle, such that the number of oracle invocations grows linearly in the number of variables n in the input constraint. We present a new approach to hashing-based approximate model counting in which the number of oracle invocations grows logarithmically in $n$, while still providing strong theoretical guarantees. Our experiments show that the new approach outperforms state-of-the-art techniques for approximate counting by 1-2 orders of magnitude in running time.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Approximate Probabilistic Inference via Word-Level Counting </title>
      <link>/publication/aaai16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/aaai16/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Hashing-based model counting has emerged as a promising approach for large-scale probabilistic inference on graphical models. A key component of these techniques is the use of xor-based 2-universal hash functions that operate over Boolean domains. Many counting problems arising in probabilistic inference are, however, naturally encoded over fi- nite discrete domains. Techniques based on bit-level (or Boolean) hash functions require these problems to be propositionalized, making it impossible to leverage the remarkable progress made in SMT (Satisfiability Modulo Theory) solvers that can reason directly over words (or bit-vectors). In this work, we present the first approximate model counter that uses word-level hashing functions, and can directly leverage the power of sophisticated SMT solvers. Empirical evaluation over an extensive suite of benchmarks demonstrates the promise of the approach.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Automatic Data Layout Generation and Kernel Mapping for CPU&#43;GPU Architectures </title>
      <link>/publication/cc2016/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/cc2016/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
The ubiquity of hybrid CPU+GPU architectures has led to renewed interest in automatic data layout generation owing to the fact that data layouts have a large impact on performance, and that different data layouts yield the best performance on CPUs vs. GPUs. Unfortunately, current programming models still fail to provide an effective solution to the problem of automatic data layout generation for CPU+GPU processors. Specifically, the interaction among whole-program data layout optimizations, data movement optimizations, and mapping of kernels across heterogeneous cores poses a major challenge to current programming systems. In this paper, we introduce a novel two-level hierarchical formulation of the data layout and kernel mapping problem for modern heterogeneous architectures. The top level formulation targets data layouts and kernel mapping for the entire program for which we provide a polynomial- time solution using a graph-based shortest path algorithm that uses the data layouts for the code regions (sections) for a given processor computed in the bottom level formulation. The bottom level formulation deals with the data layout problem for a parallel code region on a given processor, which is NP-Hard, and we provide a greedy algorithm that uses an affinity graph to obtain approximate solutions. We have implemented this data layout transformation in the new Heterogeneous Habanero-C (H2C) parallel programming framework and propose performance models to characterize the data layout impact on both the CPU and GPU. Our data layout framework shows significant performance improvements of up to 2.9 (geometric mean 1.5) on a multicore CPU+GPU compared to the manually specified layouts for a set of parallel programs running on a heterogeneous platform consisting of an Intel Xeon CPU and a NVIDIA GPU. Further, our framework also shows performance improvements of up to 2.7 (geometric mean 1.6) on just the multicore CPU, demonstrating the applicability of our approach to both heterogeneous and homogeneous hardware platforms.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Balancing Scalability and Uniformity in SAT-Witness Generator </title>
      <link>/publication/dac2014/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/dac2014/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Constrained-random simulation is the predominant approach used in the industry for functional verification of complex digital designs. The effectiveness of this approach depends on two key factors: the quality of constraints used to generate test vectors, and the randomness of solutions generated from a given set of constraints. In this paper, we focus on the second problem, and present an algorithm that significantly improves the state-of-the-art of (almost-)uniform generation of solutions of large Boolean constraints. Our algorithm provides strong theoretical guarantees on the uniformity of generated solutions and scales to problems involving hundreds of thousands of variables.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Combining the k-CNF and XOR Phase-Transitions </title>
      <link>/publication/ijcai16-cnfxor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/ijcai16-cnfxor/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
The runtime performance of modern SAT solvers on random k-CNF formulas is deeply connected with the `phase-transition&amp;rsquo; phenomenon seen empirically in the satisfiability of random k-CNF formulas. Recent universal hashing-based approaches to sampling and counting crucially depend on the runtime performance of SAT solvers on formulas expressed as the conjunction of both k-CNF and XOR constraints (known as k-CNF-XOR formulas), but the behavior of random k-CNF-XOR formulas is unexplored in prior work. In this paper, we present the first study of the satisfiability of random k-CNF-XOR formulas. We show empirical evidence of a surprising phase-transition that follows a linear trade-off between k-CNF and XOR constraints. Furthermore, we prove that a phase-transition for k-CNF-XOR formulas exists for k = 2 and (when the number of k-CNF constraints is small) for k &amp;gt; 2.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Constrained Counting and Sampling: Bridging the Gap between Theory and Practice </title>
      <link>/publication/meel-phdthesis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/meel-phdthesis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Constrained Sampling and Counting: Universal Hashing meets SAT Solving</title>
      <link>/publication/bnp16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/bnp16/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Constrained sampling and counting are two fundamental problems in artificial intelligence with a diverse range of applications, spanning probabilistic reasoning and planning to constrained-random verification. While the theory of these problems was thoroughly investigated in the 1980s, prior work either did not scale to industrial size instances or gave up correctness guarantees to achieve scalability. Recently, we proposed a novel approach that combines universal hashing and SAT solving and scales to formulas with hundreds of thousands of variables without giving up correctness guarantees. This paper provides an overview of the key ingredients of the approach and discusses challenges that need to be overcome to handle larger real-world instances.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Counting-Based Reliability Estimation for Power-Transmission Grids</title>
      <link>/publication/aaai17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/aaai17/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Modern society is increasingly reliant on the functionality of infrastructure facilities and utility services. Consequently, there has been surge of interest in the problem of quantification of system reliability, which is known to be #P-complete. Reliability also contributes to the resilience of systems, so as to effectively make them bounce back after contingencies. Despite diverse progress, most techniques to estimate system reliability and resilience remain computationally expensive. In this paper, we investigate how recent advances in hashing-based approaches to counting can be exploited to improve computational techniques for system reliability. The primary contribution of this paper is a novel framework, RelNet, that provides provably approximately correct (PAC) estimates for arbitrary networks. We then apply RelNet to ten real world power transmission grids across different cities in the U.S. and are able to obtain, to the best of our knowledge, the first theoretically sound a priori estimates of reliability between several pairs of nodes of interest. Such estimates will help managing uncertainty and support rational decision making for community resilience.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design and Verification of Distributed Phasers</title>
      <link>/publication/pact15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/pact15/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
A phaser is an expressive synchronization construct that unifies collective and point-to-point coordination with dynamic registration of parallel tasks. Each task can participate in a phaser as a signaler, a waiter, or both. The participants in a phaser may change over time as tasks are added and deleted. In this paper, we present a highly concurrent and scalable design of phasers for a distributed memory environment. Our design for a distributed phaser employs a pair of skip lists augmented with the ability to collect and propagate synchronization signals. To enable a high degree of concurrency, addition and deletion of participant tasks are performed in two phases: a &amp;ldquo;fast single-link-modify&amp;rdquo; step followed by multiple hand-over-hand &amp;ldquo;lazy multi-link-modify&amp;rdquo; steps. Verifying highly-concurrent protocols is difficult. We analyze our design for a distributed phaser using the SPIN model checker. A straight-forward approach to model checking a distributed phaser operation requires an infeasibly large state space. To address this issue, we employ a novel &amp;ldquo;message-based&amp;rdquo; model checking scheme to enable a non- approximate complete model checking of our phaser design. We guarantee the semantic properties of phaser operations by ensuring that a set of linear temporal logic formulae are valid during model checking. We also present complexity analysis of the cost of synchronization and structural operations.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Distribution-Aware Sampling and Weighted Model Counting for SAT</title>
      <link>/publication/aaai14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/aaai14/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Given a CNF formula and a weight for each assignment of values to variables, two natural problems are weighted model counting and distribution-aware sampling of satisfying assignments. Both problems have a wide variety of important applications. Due to the inherent complexity of the exact versions of the problems, interest has focused on solving them approximately. Prior work in this area scaled only to small problems in practice, or failed to provide strong theoretical guarantees, or employed a computationally-expensive maximum a posteriori probability (MAP) oracle that assumes prior knowledge of a factored representation of the weight distribution. We present a novel approach that works with a black-box oracle for weights of assignments and requires only an {\NP}-oracle (in practice, a SAT-solver) to solve both the counting and sampling problems. Our approach works under mild assumptions on the distribution of weights of satisfying assignments, provides strong theoretical guarantees, and scales to problems involving several thousand variables. We also show that the assumptions can be significantly relaxed while improving computational efficiency if a factored representation of the weights is known.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>From Weighted to Unweighted Model Counting </title>
      <link>/publication/ijcai15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/ijcai15/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
The recent surge of interest in reasoning about probabilistic graphical models has led to the development of various techniques for probabilistic reasoning. Of these, techniques based on weighted model counting are particularly interesting since they can potentially leverage recent advances in unweighted model counting and in propositional satisfiability solving. In this paper, we present a new approach to weighted model counting via reduction to unweighted model counting. Our reduction, which is polynomial-time and preserves the normal form (CNF/DNF) of the input formula, allows us to exploit advances in unweighted model counting to solve weighted model counting instances. Experiments with weighted model counters built using our reduction indicate that these counters performs much better than a state-of-the-art weighted model counter.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On Computing Minimal Independent Support and Its Applications to Sampling and Counting </title>
      <link>/publication/constraints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/constraints/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Constrained sampling and counting are two fundamental problems arising in domains ranging from artificial intelligence and security, to hardware and software testing. Recent approaches to approximate solutions for these problems rely on employing SAT solvers and universal hash functions that are typically encoded as XOR constraints of length n/2 for an input formula with n variables. As the runtime performance of SAT solvers heavily depends on the length of XOR constraints, recent research effort has been focused on reduction of length of XOR constraints. Consequently, a notion of Independent Support was proposed, and it was shown that constructing XORs over independent support (if known) can lead to a significant reduction in the length of XOR constraints without losing the theoretical guarantees of sampling and counting algorithms. In this paper, we present the first algorithmic procedure (and a corresponding tool, called MIS) to determine minimal independent support for a given CNF formula by employing a reduction to group minimal unsatisfiable subsets (GMUS). By utilizing minimal independent supports computed by MIS, we provide new tighter bounds on the length of XOR constraints for constrained counting and sampling. Furthermore, the universal hash functions constructed from independent supports computed by MIS provide two to three orders of magnitude performance improvement in state-of-the-art constrained sampling and counting tools, while still retaining theoretical guarantees.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On Hashing-Based Approaches to Approximate DNF-Counting </title>
      <link>/publication/fsttcs17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/publication/fsttcs17/</guid>
      <description>&lt;p&gt;&lt;button class=&#34;btn btn-default btn-xs&#34; type=&#34;button&#34; data-toggle=&#34;collapse&#34; data-target=&#34;#abstract_DMPV17&#34;&gt;
Abstract&lt;/button&gt;
&lt;div id=&#34;abstract_DMPV17&#34; class=&#34;collapse&#34;&gt;
Propositional model counting is a fundamental problem in artificial intelligence with a wide variety of applications, such as probabilistic inference, decision making under uncertainty, and probabilistic databases. Consequently, the problem is of theoretical as well as practical interest. When the constraints are expressed as DNF formulas, Monte Carlo-based techniques have been shown to provide a fully polynomial randomized approximation scheme (FPRAS). For CNF constraints, hashing-based approximation techniques have been demonstrated to be highly successful. Furthermore, it was shown that hashing-based techniques also yield an FPRAS for DNF counting without usage of Monte Carlo sampling. Our analysis, however, shows that the proposed hashing-based approach to DNF counting provides poor time complexity compared to the Monte Carlo-based DNF counting techniques. Given the success of hashing-based techniques for CNF constraints, it is natural to ask: Can hashing-based techniques provide an efficient FPRAS for DNF counting? In this paper, we provide a positive answer to this question. To this end, we introduce two novel algorithmic techniques: Symbolic Hashing and Stochastic Cell Counting, along with a new hash family of Row-Echelon hash functions. These innovations allow us to design a hashing-based FPRAS for DNF counting of similar complexity as that of prior works. Furthermore, we expect these techniques to have potential applications beyond DNF counting.
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
